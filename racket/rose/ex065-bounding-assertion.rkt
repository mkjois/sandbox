#lang racket

(require rosette/lang/control)
         
(require rosette/config/config rosette/config/log 
         rosette/base/value rosette/base/bool rosette/base/num
         (rename-in rosette/base/phi [phi ite])
         rosette/solver/solution rosette/kodkod/kodkod
         (only-in rosette/lang/define define-symbolic))

(current-log-handler 
 (log-handler #:name 'sym-demo-handler   ; handler name (optional)
              #:info any/c))             ; handle any message with priorty level 'info or higher

; This file: recursive functions, finized via bounded unrolling
; -------------------------------------------------------------

; This segment is a compiler from YL to formula ASTs

(require (only-in racket (if racket/if)(and racket/and)(or racket/or)))

; declarations of variables

(define-syntax-rule (define-YL-var v ...)
  (begin 
    (define v (symbolic 'v #t)) ...
    '(declare v) ...
    ))
  
; symbolic value

(struct symbolic (v c)  ; v: symbolic value
                        ; c: (symbolic) precondition under which v is valid
  #:transparent)
  
(define (concrete? v) (not (symbolic? v)))

(define (value s) 
  (if (symbolic? s) (symbolic-v s) s))

(define (control s)
    (if (symbolic? s) (symbolic-c s) #t))

; we now lift operators to operate on symbolic expressions

(define-syntax-rule (lift-ops op ...)
  (begin (lift-op op) ... ))
    
(define-syntax-rule (lift-op op)
  (begin 
    ; symbol op must come from the use of the macro (cf. 1.2.3.9 Macro-Introduced Bindings)
    ; symbol opn is freshly generated by the macro 
    (require (only-in racket (op opn)(and racket/and)))
    (define (op x y)
      (racket/if (racket/and (concrete? x) (concrete? y)) ; are both args concrete?
                 (opn x y) ; call the original concrete operator
                 (symbolic `(op ,(value x) ,(value y))
                           (bool-simplify-and (control x) (control y)))))))

; boolean simplification on path conditions

(define (bool-simplify-not a)
  (match a
    [#t #f]
    [#f #t]
    [else `(not ,a)]))

(define (bool-simplify-or a b)
  (match (list a b)
    [(list #t  _) #t]
    [(list  _ #t) #t]
    [(list _  #f)  a]
    [(list #f  _)  b]
    [else `(or ,a ,b)]))

(define (bool-simplify-and a b [c #t])
  (match (list a b c)
    [(list #f  _  _) #f]
    [(list  _ #f  _) #f]
    [(list  _  _ #f) #f]
    [(list  _ #t #t)  a]
    [(list #t  _ #t)  b]
    [(list #t #t  _)  c]
    [else `(and ,a ,b ,c)]))

(define (bool-simplify-if c pt pf)
  (racket/if (racket/and (eq? pt #t) (eq? pf #t))
             #t ; both path conditions are #t ==> new path cond is also #t
             (bool-simplify-or (bool-simplify-and c pt)
                               (bool-simplify-and (bool-simplify-not c) pf))))

; we now lift a few operators 

(lift-ops + - * / = <= >= > < and or)

; lift if does not fit the above pattern, so we define it separately
  
(define-syntax-rule (if c t f) 
  (racket/if (concrete? c)     
             (racket/if c t f)   
             (symbolic `(ite ,(value c) ,(value t) ,(value f))
                       (bool-simplify-and (control c)
                                          (bool-simplify-if (value c) (control t) (control f))))))

; (assert c e) evaluates to e if c is true,
;              fails when c is false

(define (assert c e)
  (symbolic (value e) 
            (bool-simplify-and (value c) (control e) (control c))))

; finitize a function definition 

(define unwind-depth 1)
(define-YL-var unwind-me-more)

(define-syntax-rule (define-fin-fun (fun arg ...) def ... body)
  ; modify the definition of function fun by adding the limit argument
  (begin 
    ; rewrite "outside" calls to fun
    (define-syntax-rule (fun actual (... ...))
      (renamed-fun actual (... ...) unwind-depth))

    ; redefine fun into renamed-fun, adding the call-depth limit argument
    (define (renamed-fun arg ... limit) 
      def ...
      (begin 
        ; rewrite (recursive) calls to fun inside the body of fun
        (define-syntax-rule (fun actual (... ...))
          (renamed-fun actual (... ...) (sub1 limit)))
        ; rewrite the body of fun: terminate unwinding if any 
        ; argument is symbolic and we have exhasted the depth limit
        (racket/if (racket/and (racket/or (symbolic? arg) ...) (<= limit 0))
                   (assert #f unwind-me-more)
                   body)))
    ))


;;;;-----------------------------
;;;; These are sample YL programs

(define-YL-var n x a b c d)

; partial eval test 

;(+ x (+ 1 2))

; if 

;(if (> x 0) 1 a)

; assertion 

;(+ x (assert (< a 0) b))
;(if (> x 0) (assert (< c d) b) a)

; sum

(define-fin-fun (sum n) 
  (if (= n 0) 0
      (+ n (sum (- n 1)))))
                      
;(sum 3)
(sum n)

; fibonacci 

(define-fin-fun (fib n)
  (if (= n 0) 1
      (if (= n 1) 1
          (+ (fib (- n 1)) (fib (- n 2))))))

(fib 6)
(fib n)

; double-mutually recursive fib

(define-fin-fun (fib-mut n)
  (define-fin-fun (aux-out n) 
    (define-fin-fun (aux-in n) 
      (fib-mut n))
    (aux-in n))
  (if (= n 0) 1
      (if (= n 1) 1
          (+ (aux-out (- n 1)) (aux-out (- n 2))))))

(fib-mut 6)
(fib-mut n)

; polynomials 

(define-fin-fun (poly n x coefs)
  (if (= n 0)
      (car coefs)
      (+ (car coefs) (* x (poly (- n 1) x (cdr coefs))))))

(poly 2 2 (list 1 2 3))
(poly 2 x (list 1 2 3))
(poly 2 x (list a b c))
(poly n x (list a b c d))

; our functions are first class

(foldl + d (list a b c))
(foldr + d (list a b c))

(define (IF e t f) (if e t f))
(foldl IF a (list c a b) (list b c a))

; You can't do this, we are first-order only.  Functions can't be unknowns.
; (foldr a d (list a b c)) 



;(require macro-debugger/stepper)
;(syntax->datum (expand/step #'

