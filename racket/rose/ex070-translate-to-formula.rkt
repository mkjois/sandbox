#lang racket

(require rosette/lang/control)
         
(require rosette/config/config rosette/config/log 
         rosette/base/value rosette/base/bool rosette/base/num
         (rename-in rosette/base/phi [phi ite])
         rosette/solver/solution rosette/kodkod/kodkod
         (only-in rosette/lang/define define-symbolic))

(current-log-handler 
 (log-handler #:name 'sym-demo-handler   ; handler name (optional)
              #:warning any/c))             ; handle any message with priorty level 'info or higher

; This file: recursive functions, finized via bounded unrolling
; -------------------------------------------------------------

; This segment is a compiler from YL to formula ASTs

(require (only-in racket (if racket/if)(and racket/and)(or racket/or)))

; declarations of variables

(define var-map (make-hash))  ; symbolic names --> kodkod symbolic names

(define-syntax-rule (declare-var v ...)
  (begin (declare-one-var v) ...))

(define-syntax (declare-one-var stx)
  (syntax-case stx ()
    [(_ v)
     ; name is a symbol with the same name as v but distinct from v
     ; so that the definitions in lines (1) and (2) don't conflict
     (with-syntax ([name (string->symbol (symbol->string (syntax->datum #'v)))])
       #'(begin 
           (define v (symbolic 'v #t))          ; (1) defines our symbolic var
           (define-symbolic name sym/number?)   ; (2) defines kodkod symbolic var
           (hash-set! var-map (value v) name)))]))
  
; symbolic value

(struct symbolic (v c)  ; v: symbolic value
                        ; c: (symbolic) precondition under which v is valid
  #:transparent)
  
(define (concrete? v) (not (symbolic? v)))

(define (value s) 
  (if (symbolic? s) (symbolic-v s) s))

(define (control s)
    (if (symbolic? s) (symbolic-c s) #t))

; we now lift operators to operate on symbolic expressions

(define-syntax-rule (lift-ops op ...)
  (begin (lift-op op) ... ))
    
(define-syntax-rule (lift-op op)
  (begin 
    ; symbol op must come from the use of the macro (cf. 1.2.3.9 Macro-Introduced Bindings)
    ; symbol opn is freshly generated by the macro 
    (require (only-in racket (op opn)(and racket/and)))
    (define (op x y)
      (racket/if (racket/and (concrete? x) (concrete? y)) ; are both args concrete?
                 (opn x y) ; call the original concrete operator
                 (symbolic `(op ,(value x) ,(value y))
                           (bool-simplify-and (control x) (control y)))))))

; boolean simplification on path conditions

(define (bool-simplify-not a)
  (match a
    [#t #f]
    [#f #t]
    [else `(not ,a)]))

(define (bool-simplify-or a b)
  (match (list a b)
    [(list #t  _) #t]
    [(list  _ #t) #t]
    [(list _  #f)  a]
    [(list #f  _)  b]
    [else `(or ,a ,b)]))

(define (bool-simplify-and a b [c #t])
  (match (list a b c)
    [(list #f  _  _) #f]
    [(list  _ #f  _) #f]
    [(list  _  _ #f) #f]
    [(list  _ #t #t)  a]
    [(list #t  _ #t)  b]
    [(list #t #t  _)  c]
    [else `(and ,a ,b ,c)]))

(define (bool-simplify-if c pt pf)
  (racket/if (racket/and (eq? pt #t) (eq? pf #t))
             #t ; both path conditions are #t ==> new path cond is also #t
             (bool-simplify-or (bool-simplify-and c pt)
                               (bool-simplify-and (bool-simplify-not c) pf))))

; lift if does not fit the above pattern, so we define it separately
  
(define-syntax-rule (if c t f) 
  (racket/if (concrete? c)     
             (racket/if c t f)   
             (symbolic `(ite ,(value c) ,(value t) ,(value f))
                       (bool-simplify-and (control c)
                                          (bool-simplify-if (value c) (control t) (control f))))))

; (assert c e) evaluates to e if c is true,
;              fails when c is false

(define (assert c e)
  (symbolic (value e) 
            (bool-simplify-and (value c) (control e) (control c))))

; finitize a function definition 

(define unwind-depth 4)
(declare-var unwind-me-more)

(define-syntax-rule (define-fin-fun (fun arg ...) def ... body)
  ; modify the definition of function fun by adding the limit argument
  (begin 
    ; rewrite "outside" calls to fun
    (define-syntax-rule (fun actual (... ...))
      (renamed-fun actual (... ...) unwind-depth))

    ; redefine fun into renamed-fun, adding the call-depth limit argument
    (define (renamed-fun arg ... limit) 
      def ...
      (begin 
        ; rewrite (recursive) calls to fun inside the body of fun
        (define-syntax-rule (fun actual (... ...))
          (renamed-fun actual (... ...) (sub1 limit)))
        ; rewrite the body of fun: terminate unwinding if any 
        ; argument is symbolic and we have exhasted the depth limit
        (racket/if (racket/and (racket/or (symbolic? arg) ...) (<= limit 0))
                   (assert #f unwind-me-more)
                   body)))
    ))


; we now lift a few operators 

(lift-ops + - * / = <= >= > < and or)

;;;;--------------------------------
;;;; Translate to Kodkod AST formula

(define (translate-to-kodkod s)
  (define (x v)
    (match v
      [(list '+ a b)     (sym/+ (x a)(x b))]
      [(list '- a b)     (sym/- (x a)(x b))]
      [(list '* a b)     (sym/* (x a)(x b))]
      [(list '/ a b)     (sym// (x a)(x b))]
      [(list '= a b)     (sym/= (x a)(x b))]
      [(list '> a b)     (sym/> (x a)(x b))]
      [(list '< a b)     (sym/< (x a)(x b))]
      [(list '<= a b)    (sym/<= (x a)(x b))]
      [(list '>= a b)    (sym/>= (x a)(x b))]
      [(list 'and a b)   (sym/and (x a)(x b))]
      [(list 'and a b c) (sym/and (x a)(x b)(x c))]
      [(list 'or  a b)   (sym/or  (x a)(x b))]
      [(list 'not  a)    (sym/not (x a))]
      [(list 'ite c a b) (sym/if  (x c)(x a)(x b))]
      [(list op _ ...)   (error "Unknown operator:" op)]
      [(? symbol?)  (hash-ref var-map v)]  ; var, map it to kodkod name
      [(? number?)  v]  ; constant
      [(? boolean?) v]  ; true or false
      [else (error "Unknown expression:" v)]))
  
  ; translate the value and the control
  (define v (x (value s)))
  (define c (x (control s)))
  ;(print v)(newline)
  ;(print c)(newline)
  
  ; config stuff
  (configure [bitwidth 8])
  (define solver (new kodkod%))
  
  ; Push the constraint to kodkod. Control collects all assertions, so that's
  ; all we need to push
  (send solver assert c)
  
  ; return the solution 
  (send solver solve)
  )



;;;;-----------------------------
;;;; These are sample programs

(declare-var n a b c d x)

; partial eval test 

(define p1 (+ x (+ 1 2)))

; if 

(define p2 (if (= n 0) 1 a))

; assertion 

(define p3 (+ x (assert (< a 0) b)))
(define p4 (if (> x 0) (assert (< c d) b) a))

; sum

(define-fin-fun (sum n) 
  (if (= n 0) 0
      (+ n (sum (- n 1)))))
                      
(define p5 (sum 3))
(define p6 (sum n))

; fibonacci 

(define-fin-fun (fib n)
  (if (= n 0) 1
      (if (= n 1) 1
          (+ (fib (- n 1)) (fib (- n 2))))))

(define p7 (fib 6))
(define p8 (fib n))

; double-mutually recursive fib

(define-fin-fun (fib-mut n)
  (define-fin-fun (aux-out n) 
    (define-fin-fun (aux-in n) 
      (fib-mut n))
    (aux-in n))
  (if (= n 0) 1
      (if (= n 1) 1
          (+ (aux-out (- n 1)) (aux-out (- n 2))))))

(define p9 (fib-mut 6))
(define p10 (fib-mut n))

; polynomials 

(define-fin-fun (poly n x coefs)
  (if (= n 0)
      (car coefs)
      (+ (car coefs) (* x (poly (- n 1) x (cdr coefs))))))

(define p11 (poly 2 2 (list 1 2 3)))
(define p12 (poly 2 x (list 1 2 3)))
(define p13 (poly 2 x (list a b c)))
(define p14 (poly n x (list a b c d)))

; our functions are first class

(define p15 (foldl + d (list a b c)))
(define p16 (foldr + d (list a b c)))

(define (IF e t f) (if e t f))
(define p17 (foldl IF a (list c a b) (list b c a)))

; You can't do this, we are first-order only.  Functions can't be unknowns.
; (foldr a d (list a b c)) 

;;;;----------------------------

;(translate-to-kodkod decls)
(define test (assert (= 6 (sum n)) 1))
;test
(define sol (translate-to-kodkod test))

(sleep 1) 
(unless (sat? sol)
  (error 'synthesis "No solution found!"))
(printf "\nSOLUTION:\n")
(for ([sym (list n a b c d x)])
  (let* ([name (value sym)]
         [kodkod-name (hash-ref var-map name)])
    (printf "~s := ~s\n" name (sol kodkod-name))))


; (require macro-debugger/stepper)
; (syntax->datum (expand/step #'(define-YL-var n)))
